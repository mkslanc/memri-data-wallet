import 'date_time_converter.dart';

CREATE TABLE items
(
    row_id             INTEGER PRIMARY KEY,
    id                 TEXT     NOT NULL,
    type               TEXT     NOT NULL,
    dateCreated        INTEGER MAPPED BY `const DateTimeConverter()` NOT NULL,
    dateModified       INTEGER MAPPED BY `const DateTimeConverter()` NOT NULL,
    dateServerModified INTEGER MAPPED BY `const DateTimeConverter()`,
    deleted            BOOLEAN  NOT NULL DEFAULT false,
    syncState          TEXT     NOT NULL DEFAULT 'create',
    fileState          TEXT     NOT NULL DEFAULT 'skip',
    syncHasPriority    BOOLEAN  NOT NULL DEFAULT false
);

CREATE
    UNIQUE INDEX idx_items_id on items (id);
CREATE
    INDEX idx_items_type_dateServerModified on items (type, dateServerModified);


CREATE TABLE edges
(
    self            INTEGER PRIMARY KEY,
    source          INTEGER NOT NULL,
    name            TEXT    NOT NULL,
    target          INTEGER NOT NULL,
    syncState       TEXT    NOT NULL DEFAULT 'create',
    syncHasPriority BOOLEAN NOT NULL DEFAULT false,
    FOREIGN KEY (source) REFERENCES items (row_id),
    FOREIGN KEY (target) REFERENCES items (row_id),
    FOREIGN KEY (self) REFERENCES items (row_id)
);
CREATE
    INDEX idx_edges_source_name on edges (source, name);
CREATE
    INDEX idx_edges_target_name on edges (target, name);


CREATE TABLE integers
(
    item  INTEGER NOT NULL,
    name  TEXT    NOT NULL,
    value INTEGER NOT NULL,
    FOREIGN KEY (item) REFERENCES items (row_id)
) AS IntegerDb;
CREATE
    UNIQUE INDEX idx_integers_item_name on integers (item, name);
CREATE
    INDEX idx_integers_name_value on integers (name, value);
CREATE
    INDEX idx_integers_name_item on integers (name, item);


CREATE TABLE strings
(
    item  INTEGER NOT NULL,
    name  TEXT    NOT NULL,
    value TEXT    NOT NULL,
    FOREIGN KEY (item) REFERENCES items (row_id)
) AS StringDb;

CREATE
    UNIQUE INDEX idx_strings_item_name on strings (item, name);
CREATE
    INDEX idx_strings_name_value on strings (name, value);
CREATE
    INDEX idx_strings_name_item on strings (name, item);


CREATE TABLE reals
(
    item  INTEGER NOT NULL,
    name  TEXT    NOT NULL,
    value REAL    NOT NULL,
    FOREIGN KEY (item) REFERENCES items (row_id)
) AS RealDb;
CREATE
    UNIQUE INDEX idx_reals_item_name on reals (item, name);
CREATE
    INDEX idx_reals_name_value on reals (name, value);
CREATE
    INDEX idx_reals_name_item on reals (name, item);

CREATE TABLE navigationState
(
    sessionID TEXT PRIMARY KEY NOT NULL,
    pageLabel TEXT             NOT NULL,
    state     BLOB             NOT NULL
);

CREATE VIRTUAL TABLE strings_search USING fts5
(
    content= "strings",
    item UNINDEXED,
    name UNINDEXED,
    value,
    tokenize = 'porter'
);

-- Triggers to keep the FTS index up to date.
CREATE TRIGGER strings_search_after_insert
    AFTER INSERT
    ON strings
BEGIN
    INSERT INTO strings_search(item, name, value) VALUES (new.item, new.name, new.value);
END;
CREATE TRIGGER strings_search_before_delete
    BEFORE DELETE
    ON strings
BEGIN
    DELETE FROM strings_search WHERE name = old.name AND item = old.item;
END;
CREATE TRIGGER strings_search_after_update
    AFTER UPDATE
    ON strings
BEGIN
    UPDATE strings_search
    SET item  = new.item,
        name  = new.name,
        value = new.value
    WHERE item = new.item
      AND name = new.name;
END;